\documentclass{draft}

\author[]{Fjalar~J~de~Haan\thanks{\textit{Corresponding author. Email:}~f.dehaan@deakin.edu.au,~fjalar@fjalar.org}}

\affil[]{Planet A, Centre for Integrative Ecology, \mbox{Deakin University, Australia}}

\date{}

\everymath{\displaystyle}
\begin{document}

\title{LUTO II (neoLUTO)}

\maketitle

\begin{abstract}
	\noindent This document provides an overview of the LUTO II modelling software package.
\end{abstract}

\tableofcontents

\newpage

\section{Introduction}
This document provides an overview of the software package of LUTO II\@. It describes its architecture, the mathematical model behind the cost-minimising dynamics, the data required and how to build them from the raw datasets. It also gives instructions on how to set up and run the model.

% more on luto pedigree

The LUTO II model simulates land-use change. The model is spatially explicit and the modelled territory is discretised into $1 \times 1$ km\textsuperscript{2} (approximately) grid cells. These grid cells are represented in the model as 1D arrays, with the array entry representing the land use. A \emph{land use} is, as the name suggests, the way land is used, which typically means what kind of crop is grown or what type of livestock grazes on it. Associated with the land use are production costs and yields, both annual, which allow the model to decide which land use is optimal for a cell. There is a list of land uses considered and these are represented by integer values (e.g. `Apples' $ = 1$, `Dairy' $ = 7$). Thus, at the heart of it, land-use change is modelled by a changing integer array. This integer array is called the land-use map or \emph{lumap} for short.

In addition to the land use, the model also takes into account \emph{land management}. Apples, for example, can be cultivated with (or without) irrigation, using organic methods (or not) and so on as well as combinations of such land managements. Depending on the land management, there will typically be different production costs and different yields associated with the land use. Irrigation is more expensive but may be expected to increase yields. There is a list of land managements and these are, like land uses, represented by integer values. Conventional, dry-land agriculture is the default and represented by zero, while irrigation is represented by one. The model currently only considers conventional dry land and irrigation as land managements. Thus there is also a land-management map, or \emph{lmmap} for short.

The \emph{lumap} and \emph{lmmap} are the dependent variables of the model. Everything else is calculated on the basis of these two 1D arrays. The mechanisms driving the dynamics are economic. In the original CSIRO LUTO, the economic rationale was profit maximisation, i.e.\ farmers were supposed to cultivate whatever would profit them most (subject to some risk-based thresholds). In LUTO II the economic rationale is more systemic. The idea is that the agricultural system tries to meet demands (inputs to the model) the best it can, subject to certain constraints, while trying to minimise the total cost of production. Thus, using a yearly time step, the model is fed new demands and the model's solver produces a new land-use map.

Minimising cost while meeting demand means the model is trading off the expenditure of production against the yield of the crop or livestock. In addition to this, there are \emph{transition costs} associated with switching from one land use to another. This means that if a grid cell changes from growing apples to raising cattle, there is not only the new production cost to be paid (which may be lower) but also a transition cost. These transition costs subsume various costs of switching (including infrastructural investments and changed irrigation costs). Transition costs introduce `memory' into the model, avoiding that the land-use map changes unrealistically much at each time step as it attempts to meet demand at lowest cost.

LUTO II, like its progenitor, is an optimisation model. The economic rationale is formalised as a linear programme, which is then solved using external, commercial, black-box, closed-source solver software (GUROBI for LUTO II and CPLEX for LUTO I). The mathematical model of LUTO II is an actual linear programme but an alternative solver prototype using binary decision variables is also part of the package.

The model is solved under various constraints. One constraint ensures that all of every cell is in use. That is, there is always \emph{some} land use on a cell and all of it is used. In principle, a cell can multiple `fractional' land uses, though in practice, if the territory consists of many cells this seems not to occur. Another constraint is that the deviation of production from the demanded quantities should be minimal. This is a so-called soft constraint. These two constraints are an essential part of the model formulation. The remaining constraints are concerned with environmental targets and they can be switched on or off. Of these, water use is the first considered and the only one currently implemented. The water constraint demands that current water use relative to the water yield (how much runs of) in a river region should not exceed the water use in 2010 relative to pre-European yields (which are estimated using 1985 data and assuming deeply-rooted vegetation). Water is implemented as a hard constraint.

\section{Architecture of the model}
The LUTO II software is contained in a Python 3 package. The package structure (see Figure \ref{fig:package}) is meant to reflect the different stages of the modelling process. The various sub packages live under a main package called \mintinline{python}{luto}. Thus there is a sub package concerned with the loading of data (\mintinline{python}{luto.data}), one with cost calculations (\mintinline{python}{luto.economics}) and so on. Each sub package typically contains several modules, each with several functions.

A small number of design principles has generally been adhered to, though not into the extreme. The most important were:
\begin{itemize}
	\item Avoiding global variables and avoiding statefullness. The only exception to this being the \mintinline{python}{luto.solvers.simulation} module which has the express purpose of keeping the state of a simulation.
	\item Avoiding object orientation where possible. The notable exception is again \mintinline{python}{luto.solvers.simulation} which uses a \mintinline{python}{class Data}.
	\item Functions should be \emph{pure}. This means that a function should return something, it should always return the same thing if given the same arguments and it should do nothing else (`no side effects'). Deviations from this principle are typically explicit (e.g.\ setters and functions to write to file).
	\item Dependencies should be few. Generally, the external dependencies are limited to Numpy and Pandas (almost everything uses these) and things like HDF5 libraries. Dependencies on other LUTO modules are used where unavoidable, e.g.\ in a module where many things come together. Again, in \mintinline{python}{luto.solvers.simulation} there are of course plenty of internal imports.
\end{itemize}

The user interface of the model is the \mintinline{python}{luto.solvers.simulation} module. Importing this module will implicitly load the \mintinline{python}{data} module. It will use the parameters set in the \mintinline{python}{luto.settings} module. At this point, those parameters are limited to directory locations and some settings relating to the water constraints. If all the requisite data is available where it should be (\texttt{input/} by default), this is sufficient to run the model. One can run `interactively', that is, from the prompt of a Python interpreter or call the functions of the \mintinline{python}{luto.solvers.simulation} module from a run script. Preparing the input data and setting up the model to run is discussed in Sections~\ref{sec:dataprep} and~\ref{sec:running}, respectively.

\floatstyle{plain}
\restylefloat{figure}
\begin{figure}
\vbox{%
\dirtree{%
.1 /.
.2 \textbf{luto/} \DTcomment{main sub-package, i.e.\ `src'}.
	.3 \textbf{data/} \DTcomment{loading of inputs}.
		.4 __init__.py \DTcomment{actual data module}.
		.4 economic.py \DTcomment{data preparation functions}.
		.4 spatial.py \DTcomment{legacy code}.
		.4 temporal.py \DTcomment{legacy code}.
	.3 \textbf{economics/} \DTcomment{costs, yields and water calculations}.
		.4 cost.py \DTcomment{production cost functions}.
		.4 quantity.py \DTcomment{yield functions}.
		.4 transitions.py \DTcomment{transition cost functions}.
		.4 water.py \DTcomment{water use and yield functions}.
	.3 \textbf{reporting/} \DTcomment{derivative output calculations}.
	.3 \textbf{solvers/} \DTcomment{functions and interface to run model}.
		.4 resfactor.py \DTcomment{functions for spatial coarse graining}.
		.4 simulation.py \DTcomment{interface module for running simulations}.
		.4 solvers.py \DTcomment{solver function calling GUROBI}.
		.4 stacksolver.py \DTcomment{alternative solver (toy model stage)}.
	.3 \textbf{tools/} \DTcomment{utility functions}.
		.4 __init__.py \DTcomment{various utility functions}.
		.4 compmap.py \DTcomment{cross-tabulation functions}.
		.4 highposgtiff.py \DTcomment{to write lumaps to geotiffs}.
		.4 plotmap.py \DTcomment{lumap viewer using matplotlib}.
		.4 write.py \DTcomment{write simulation output to files in a dir}.
	.3 settings.py \DTcomment{settings like file locations and parameters}.
.2 \textbf{input/} \DTcomment{*.npy, *.csv and *.hdf5 data files}.
.2 \textbf{output/} \DTcomment{model results, lumaps and lmmaps etc.}.
.2 \textbf{docs/} \DTcomment{documentation, including this file}.
}
}
\caption{Directory structure of LUTO II Python package.}
\label{fig:package}
\end{figure}

\subsection{Loading data (\mintinline{python}{luto.data})}\label{subsec:data}
The main idea behind the \mintinline{python}{luto.data} module is to have a namespace for all input data and parameters. For example, importing the module, by issuing
\begin{minted}{python}
	import luto.data as data
\end{minted}
will make the list of land uses available as \mintinline{python}{data.LANDUSES}. Data is made available in three ways, (1) by reading the data directly from a file, typically a *.npy, *.csv or *.hdf5 file, by (2) post-processing data read from file to some extent, or (3) by defining variables in the code directly (i.e.\ `magic numbers'). This third option is obviously to be avoided and the only magic number is the starting year, 2010, which is added to the year index (zero-based) whenever an actual calendar year is required.

The files required by the \mintinline{python}{luto.data} module are:
\begin{itemize}
	\item \ldots
\end{itemize}

The data in the files is used to \emph{infer} various parameters of the modelling problem. In other words, in principle, the code knows nothing about the particulars of the modelling problem under consideration. Things like the spatial extent (number of grid cells), the lists of land uses and land managements and so on, the model obtains from inspecting the data files. This has the obvious advantage that the model is not tied to a certain number of cells or a particular set of land uses.

There are complications to this picture. The most notable being the following. The list of \emph{land uses} (whatever lives on the land) is not the same as, and not in a one-one relation with, the list of \emph{products} those land uses yield. For example, `Sheep - natural land' (a land use) yields `SHEEP - NATURAL LAND MEAT' as well as `SHEEP - NATURAL LAND WOOL'. To complicate matters further, the list of \emph{commodities} that are demanded (the time series of which are a key input to the model) are not the same nor in a one-one relationshep with either the list of land uses or products. For example, the demand for wool is indifferent to whether the sheep grazed on natural or modified land. So, in the list of products there is just `sheep wool'.

To avoid confusion and force useful errors, the three lists (\mintinline{python}{data.LANDUSES}, \mintinline{python}{data.PRODUCTS}, \mintinline{python}{data.COMMODITIES}) use different cases (sentence, all upper and all lower case, respectively). Nevertheless, the lists are produced by inferring the list of land-uses from the agricultural data and a host of string manipulations. This is clearly error prone in light of future extensions. Moreover, the \emph{conversions} from e.g.\ land-use to product representation, which are necessary to set up the linear programme in the solver, employ conversion matrices. These matrices are defined in the \mintinline{python}{luto.data} module following the above logic.

The situation with the land-uses, products and commodities makes the \mintinline{python}{luto.data} module cluttered, hard to read and a potential source of future bugs. The schema can likely be simplified to just two lists and some processing could be factored out while other things can be turned into file reads. At the moment however, the module works and once loaded the complications are at any rate not so visible.

Since the model avoids global dependencies, the \mintinline{python}{luto.data} loaded module needs to be explicitly passed as an argument to all functions that need it. While this may appear as complicating things unnecessarily, there are two key advantages to this approach:
\begin{enumerate}
	\item Many functions would take very long to import if they had the \mintinline{python}{luto.data} module as a hard-coded dependency. Those functions are now fairly light weight.
	\item One can also pass a \emph{different} data object to those functions. For example, some small dummy object for testing purposes. The \mintinline{python}{luto.simulation} module makes extensive use of this possibility by creating derivative data objects with many grid cells masked out to save computational space and time (see Section~\ref{subsec:solvers}).
\end{enumerate}

The \mintinline{python}{luto.data} sub-package has several modules but only the \texttt{/__init__.py} is used to load it. The modules
\mintinline{python}{luto.data.spatial} and \mintinline{python}{luto.data.temporal} are legacy code. The \mintinline{python}{luto.data.economic} module, however, is used in the data preparation (see Section~\ref{sec:dataprep}).

\subsection{Economic calculations (\mintinline{python}{luto.economics})}
The sub-package \mintinline{python}{luto.economics} is concerned with calculating the production costs, transition costs and yields related to the land uses. This sub-package also contains a module to calculate water uses and yields. All functions in these modules are pure and most require a data object as an argument.

The calculations in this sub-package are typically returned in a matrix format, including `matrices' with more than two indices. This is partially because it is the natural format from the perspective of the mathematical formulation and GUROBI solver API. It also enables the use of some linear algebra tools making for compacter code. This at the expense of a lot of matrices of various shapes in the model. To keep overview and avoid errors, the following convention were used: A matrix data type is denoted by a letter followed by an underscore and a list of indices, e.g. \mintinline{python}{c_mrj}. The letter relates to the quantity in question (here `cost') and the indices run over various ranges, depending on what the axis represents. See Table~\ref{tab:indices} for the constantly recurring indices and the sets they enumerate.
\begin{table}
\centering
\begin{tabular}{lllll}
Index   & Set         & Range                                                & Set in LUTO II                                           & Range in LUTO II                                     \\
$ r $ & Grid cells  & $7 \times 10^7$ &                                                          & \mintinline{python}{data.NCELLS}  \\
$ j $ & Land uses   & 28                                                   & \mintinline{python}{data.LANDUSES}    & \mintinline{python}{data.NLUS}    \\
$ m $ & Land man's   & 2                                                   & \mintinline{python}{data.LANDMANS}    & \mintinline{python}{data.NLMS}    \\
$ p $ & Products    & 32                                                   & \mintinline{python}{data.PRODUCTS}    & \mintinline{python}{data.NPRS}    \\
$ c $ & Commodities & 26                                                   & \mintinline{python}{data.COMMODITIES} & \mintinline{python}{data.NCMS}
\end{tabular}
\caption{Common indices for matrix-like quantities.}
\label{tab:indices}
\end{table}


\subsubsection{Production costs (\mintinline{python}{luto.economics.cost})}
A major part of the optimisation logic are the annual production costs, i.e.\ what it costs to have a certain crop or livestock on a particular grid cell. These costs depend not only on the land use, but also on spatial location as well as the land-management type (whether it is irrigated or not) and the year. The \mintinline{python}{cost} module provides several functions to calculate these annual production costs. Of these, \mintinline{python}{get_cost_matrices()} provides the costs in the matrix format used by the solver. The actual cost calculations are done in separate functions (\mintinline{python}{get_cost_crop()} and \mintinline{python}{get_cost_lvstk()}). If one wants just the production costs of a certain land use and land management combination in a certain year, there is the function \mintinline{python}{get_cost(data, lu, lm, year)}, which returns a 1D spatial array with the cost per grid cell.

Production costs of crops are computed as \emph{fixed} plus \emph{area} plus \emph{quantity} costs. The fixed costs in turn are the sum of fixed \emph{labour}, \emph{operational} and \emph{depreciation} costs. These component costs come from data and only few operations are involved in the computation of the total production cost. Additionally, if it concerns an irrigated crop, there are water costs which are the product of the volume of water required and the delivery costs.

A similar breakdown holds for livestock production costs, with some amendments. The quantity costs in the data are now given per head so multiplication by a `yield potential' (number of heads per hectare) is necessary. In the water costs, now drinking water also needs to be included (regardless of whether the pasture is irrigated or not).

\subsubsection{Transition costs (\mintinline{python}{luto.economics.transitions})}
The transition costs are the costs of changing the land-use or land-management on a certain cell. The key function in this module is \mintinline{python}{get_transition_matrices()} which returns the transition matrices in a $t_{mrj}$ format. Thus the entry $t_{1, 3, 7}$ is the cost of switching cell number 3 (which is the fourth cell, arrays are zero based) to land use 7 (`Grapes') under land management 1 (`irr', i.e.\ irrigation). The knowledge about what the land-use and land-management it is switching \emph{from} is subsumed in the $t_{mrj}$ matrix, so naturally the current lumap and lmmap are arguments to the \mintinline{python}{get_transition_matrices()} function.

The actual transition costs are computed from a number of parts:
\begin{enumerate}
	\item `Raw' transition costs from one land use to another
	\item The difference in water licence costs after and before
	\item Irrigation infrastructure costs, if applicable
	\item Foregone income at 3 times the annual production costs
\end{enumerate}

Finally, the costs are amortised at 5\% with a horizon of 30 years.

\subsubsection{Yields (\mintinline{python}{luto.economics.quantity})}

Yields refer to the quantities of \emph{product} that can be obtained from a land use on a certain grid cell. While a land use has only one associated production cost, it can have several associated yields --- for example, as mentioned before, a land use like `Sheep - natural land' yields `SHEEP - NATURAL LAND MEAT' as well as `SHEEP - NATURAL LAND WOOL'.

The functions in the \mintinline{python}{luto.economics.quantity} module are parallel to their counterparts in the \mintinline{python}{costs} module --- with the crucial distinction that costs are for land uses, while yields pertain to products. Thus the module features the following functions. \mintinline{python}{get_quantity_matrices()} provides the yields in the matrix format used by the solver. The actual yield calculations are done in separate functions (\mintinline{python}{get_quantity_crop()} and \mintinline{python}{get_quantity_lvstk()}). If one wants just the yields of a certain product and land management combination in a certain year, there is the function \mintinline{python}{get_quantity(data, pr, lm, year)}, which returns a 1D spatial array with the cost per grid cell.

The yields for crops come directly from the input data and are only converted from per hectare to per cell units (in \mintinline{python}{get_quantity_crop()}). Also, for crops the correspondence between land uses and products is one-one. The calculations for livestock (in \mintinline{python}{get_quantity_lvstk()}) yields are a bit more involved and will be discussed below. The function \mintinline{python}{get_quantity()}, which branches to the before mentioned functions, additionally applies two multipliers, (1) the climate change impacts (via \mintinline{python}{get_ccimpact()}, interpolating input data) and (2) yield increases, i.e.\ productivity increases (directly from data).

The function \mintinline{python}{get_quantity_lvstk()} first infers which livestock and vegetation type are involved by calling the function \mintinline{python}{lvs_veg_types()} which determines this based on the product string. So, `SHEEP - NATURAL LAND WOOL' corresponds to livestock type `SHEEP' and vegetation type `NATL' (i.e.\ natural). This information is then used to calculate a \emph{yield potential} using the function \mintinline{python}{get_yield_pot()} which effectively is how many heads per hectare can be yielded.

The livestock yield data holds both the total herd size and the fraction available for use (e.g.\ slaughter or export). The product of these to factors gives a per-head, per-hectare yield. Thus \mintinline{python}{get_quantity_lvstk()} multiplies this by the yield potential and converts from per-hectare to per-cell units.

\subsection{Solving and running (\mintinline{python}{luto.solvers})}\label{subsec:solvers}

The heart of the model, that is, where the next land use map is actually computed is the \mintinline{python}{solve()} function --- `the solver' --- in the \mintinline{python}{luto.solvers.solver} module. This function takes all relevant input matrices, the demands, constraints and two conversion matrices as arguments and returns the new land-use and land-man' maps. Since this function solves the system for one time step at a time and a considerable list of arguments is required, there is an interface to solving the model provided in \mintinline{python}{luto.solvers.simulation}. The \mintinline{python}{simulation} module takes care of computing the input matrices, keeps track of the solved lumaps and lmmaps and provides a number of convenience functions. Section~\ref{sec:running} describes in some detail how to use the \mintinline{python}{simulation} module.

\subsubsection{Spatial coarse graining and spatial sub-setting}

\emph{Resfactor (lossy)}

To facilitate faster testing, one can run the model in a `coarse-grained' fashion. The idea is simply to present the solver with a sampled subset of the spatial domain and correspondingly sliced matrices. This facility is called `resfactor' after a similar functionality in LUTO I. The sampling can be either linear or quadratic, which means that if a sampling rate of $n$ is given, either every $n$\textsuperscript{th} or every $n \times n$\textsuperscript{th} cell is included. The linear mode produces sampling artefacts, so the quadratic mode should always be used. The sampling is implemented with a multiplicative mask. The following three functions are involved in recovering the maps from the coarse-grained solver output: \mintinline{python}{simulation.uncourse1D()}, \mintinline{python}{simulation.uncourse2D()} and \mintinline{python}{simulation.uncoursify()}.

Thought the resfactor can be set manually with the \mintinline{python}{simulation.set_resfactor()} function, for consistent settings it is recommended to instead pass the resfactor as an argument to \mintinline{python}{simulation.run()}.

The speed up is slightly better than proportional to the fraction of cells sampled. It should be superfluous to note that solving a coarse-grained map and then resizing the outputs does not provide the same results as an actual solve on the full map. Simulation results obtained with spatial coarse graining are to be used for quick inspections and sense checking in testing contexts only.

\emph{Subsetting (lossless)}

Since the grid cells with land use `Non-agricultural land' are not changed by the solver, there is no loss in solving the lumap with these cells excluded and reinserting them afterwards. This is precisely what is done when the solving is done using the \mintinline{python}{luto.solvers.simulation} interface. Like the spatial coarse graining, the sub-setting of the input map is achieved with a multiplicative map. In fact, when coarse graining is on, the two masks are indeed multiplied. The removed cells are re-inserted post-solve by the \mintinline{python}{simulation.reconstitute()} function. The speed up is proportional to the fraction of `Non-agricultural land' cells in the lumap and there is no loss of accuracy as there is no approximation.

Not only the lumap and lmmap are spatially explicit and therefore amenable to this sort of sub-setting or coarse-graining. In fact, many of the input data are spatially explicit and calculations could be sped up considerably if e.g.\ costs and yields were computed on the same fraction of the cells as the lumap and lmmap. The functions in the \mintinline{python}{luto.economics} module are agnostic to the spatial extent and pure, so if they were passed a data object on a different, smaller, spatial domain, they would not mind.

\emph{The} \mintinline{python}{class Data}

To make use of this, the \mintinline{python}{luto.solvers.simulation} module contains a class definition for a data object that can be spatially subsetted. This is a simple class with no methods. All it aims to do is to expose the same fields (at any rate the upper-case fields) as the \mintinline{python}{luto.data} module but defined on the masked spatial domain. To achieve this, it copies all the upper-case fields and applies the combined (multiplied) masks of resfactor and the lossless subsetting described earlier to the spatial fields.

// Local matrix getters.

\emph{The} \mintinline{python}{simulation.step()} \emph{function}

To call the solver, the \mintinline{python}{luto.simulation} module uses the \mintinline{python}{simulation.step()} function.


% resfactor

% stacksolver

Since the functions for e.g.\ cost calculations, receive a \mintinline{python}{data} object as an argument % slicing the spatial extent...
Extensive use of this is being made by the \mintinline{python}{luto.simulation} module
% simulation module and Data class.

\section{Optimisation mathematics}\label{sec:mathematics}

\section{Data requirements and preparation}\label{sec:dataprep}

\section{Running the model}\label{sec:running}


\end{document}

